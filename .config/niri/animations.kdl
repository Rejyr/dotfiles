animations {
    // off
    // slowdown 3.0
    exit-confirmation-open-close {
        off
    }

    window-resize {
        custom-shader r"
// Example: cropped next texture if it's bigger than the current geometry, and
// crossfade between previous and next texture otherwise.
vec4 crossfade_or_crop_next(vec3 coords_curr_geo, vec3 size_curr_geo) {
    vec3 coords_next_geo = niri_curr_geo_to_next_geo * coords_curr_geo;
    vec3 coords_prev_geo = niri_curr_geo_to_prev_geo * coords_curr_geo;

    vec3 coords_crop = niri_geo_to_tex_next * coords_next_geo;
    vec3 coords_stretch = niri_geo_to_tex_next * coords_curr_geo;
    vec3 coords_stretch_prev = niri_geo_to_tex_prev * coords_curr_geo;

    // We can crop if the current window size is smaller than the next window
    // size. One way to tell is by comparing to 1.0 the X and Y scaling
    // coefficients in the current-to-next transformation matrix.
    bool can_crop_by_x = niri_curr_geo_to_next_geo[0][0] <= 1.0;
    bool can_crop_by_y = niri_curr_geo_to_next_geo[1][1] <= 1.0;
    bool crop = can_crop_by_x && can_crop_by_y;

    vec4 color;

    if (crop) {
        // However, when we crop, we also want to crop out anything outside the
        // current geometry. This is because the area of the shader is unspecified
        // and usually bigger than the current geometry, so if we don't fill pixels
        // outside with transparency, the texture will leak out.
        //
        // When crossfading, this is not an issue because the area outside will
        // correspond to client-side decoration shadows, which are already supposed
        // to be outside.
        if (coords_curr_geo.x < 0.0 || 1.0 < coords_curr_geo.x ||
                coords_curr_geo.y < 0.0 || 1.0 < coords_curr_geo.y) {
            color = vec4(0.0);
        } else {
            color = texture2D(niri_tex_next, coords_crop.st);
        }
    } else {
        // If we can't crop, then crossfade.
        color = texture2D(niri_tex_next, coords_stretch.st);
        vec4 color_prev = texture2D(niri_tex_prev, coords_stretch_prev.st);
        color = mix(color_prev, color, niri_clamped_progress);
    }

    return color;
}

// This is the function that you must define.
vec4 resize_color(vec3 coords_curr_geo, vec3 size_curr_geo) {
    // You can pick one of the example functions or write your own.
    return crossfade_or_crop_next(coords_curr_geo, size_curr_geo);
}
"
    }
}
