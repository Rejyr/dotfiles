(self.webpackChunkLiveTL=self.webpackChunkLiveTL||[]).push([[535],{2535:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>$});var o=n(4040),r=n(3521);function s(e){let t;return{c(){t=(0,o.bG)("div"),t.textContent="We've been working very closely with the developer of MChad to improve our\n      integration. This update brings translation room retries, a move to https,\n      fixes for message timestamps, and more! In the future, you will also be\n      able to selectively filter individual translators from MChad as well."},m(e,n){(0,o.$T)(e,t,n)},d(e){e&&(0,o.og)(t)}}}function a(e){let t;return{c(){t=(0,o.bG)("span"),t.textContent="MChad API Improvements",(0,o.Lj)(t,"slot","header")},m(e,n){(0,o.$T)(e,t,n)},d(e){e&&(0,o.og)(t)}}}function i(e){let t,n;return t=new r.EB({props:{$$slots:{header:[a],default:[s]},$$scope:{ctx:e}}}),{c(){(0,o.YC)(t.$$.fragment)},m(e,r){(0,o.ye)(t,e,r),n=!0},p(e,n){const o={};4&n&&(o.$$scope={dirty:n,ctx:e}),t.$set(o)},i(e){n||((0,o.Ui)(t.$$.fragment,e),n=!0)},o(e){(0,o.et)(t.$$.fragment,e),n=!1},d(e){(0,o.vp)(t,e)}}}function l(e){let t,n,s;function a(t){e[1](t)}let l={$$slots:{default:[i]},$$scope:{ctx:e}};return void 0!==e[0]&&(l.value=e[0]),t=new r.it({props:l}),o.Vn.push((()=>(0,o.ak)(t,"value",a))),{c(){(0,o.YC)(t.$$.fragment)},m(e,n){(0,o.ye)(t,e,n),s=!0},p(e,[r]){const s={};4&r&&(s.$$scope={dirty:r,ctx:e}),!n&&1&r&&(n=!0,s.value=e[0],(0,o.hj)((()=>n=!1))),t.$set(s)},i(e){s||((0,o.Ui)(t.$$.fragment,e),s=!0)},o(e){(0,o.et)(t.$$.fragment,e),s=!1},d(e){(0,o.vp)(t,e)}}}function u(e,t,n){let o=[];return[o,function(e){o=e,n(0,o)}]}class c extends o.f_{constructor(e){super(),(0,o.S1)(this,e,u,l,o.N8,{})}}const $=c}}]);